
# Swagger Server POC

## This branch leverages Swagger JSON
This is a swagger JSON built by the [swagger-codegen](https://github.com/swagger-api/swagger-codegen) project.

Step 1: Install go-swagger

* `
brew tap go-swagger/go-swagger && 
brew install go-swagger
`

Step 2: Install dependencies using Glide (install using `brew install glide`)

`glide install`

Step 3:

`go build main.go`

Step 4: 

`go run main.go`

# Generating a Server

## Resources used to create Swagger YAML that includes definitions and operations:
* [Swagger Toolbox](https://swagger-toolbox.firebaseapp.com/) - YAML --> JSON

In order to generate a server:

`swagger generate server -f ./swagger/swagger.yml`

This command will spill out the actions it takes as it generates your new REST server. Do not follow the advice at the end of the output. There’s an alternate mechanism to do so. Just use glide to update dependencies: `glide up -v`.


# Generating the UI

## Downloading SwaggerUI files

SwaggerUI can be downloaded from their GitHub Repo. Once downloaded, place the content of dist folder somewhere in your Go project. Then generate the spec:

`swagger generate spec -o ./swagger/swagger.json --scan-models`

After that, move swagger.json file to swaggerui folder, and inside index.html change url to ./swagger.json (url: "./swagger.json").

The `main.go` has two go routines that spin up two goroutines - one for each server. 

The Swagger UI dist is served using the following logic and handler function:

```
fs := http.FileServer(http.Dir("./swaggerui"))
http.Handle("/swaggerui/", http.StripPrefix("/swaggerui/", fs))
```

## Some Important Notes in this Branch

One one generates the server from the base path as follow: `swagger generate server -f swagger.yml` there are important distinctions made from the main branch.

To understand the geneerated code please reference the /models. In here, you’ll find the schemas  outlined in the swagger.yml file turned into source code. If you open one, like many files generated by Swagger, you’ll see it reads `// DO NOT EDIT`. But then there’s that function there, Validate(). If you want to do advanced validation for custom patterns or inter-field relations not covered by Swagger’s validators you’ll have to edit this file. 

For this POC exercise the scope was to not edit those files. But we can see, for example, that the Timezone object has a field, Timezone.Timezone, which is a string, and which has to be at least three bytes long.

The other thing you’ll have to look at is the restapi/operations folder. In here you’ll find GET and POST operations, the parameters they accept, the responses they deliver, and lots of functions only Swagger cares about. But there are a few we care about.

Here’s how we craft the GET response. Inside `handlers.go`, you’re going to need to extract the requested timezone, get the time of day, and then return either a success message or an error message. Looking in the operations files, there are a methods for good and bad returns, as we described in the swagger file.

Specific to the `GetClock`, the first thing to notice here is the params field: we’re getting a customized, tightly bound object from the server. There’s no hope of abstraction here. The next is that we made the Timezone input optional, so here we have to check if it’s nil or not. if it isn’t, we need to set it. We do this here because we need to cast params. Timezone into a pointer to a string.

In the error cases for both the `GetClock` and the `PostClock` there are multiple references. We have a model, an operation, and the swag package's resources. In order to satisfy Swagger’s strictness, we use only what Swagger offers: for our 404 case, we didn’t find the timezone requested, so we’re returning the ErrorResponse model populated with a numeric code and a string, extracted via fmt, from the err returned from our time function. The 404 case for get is called, yes, NewClockGetNotFound, and then WithPayload() decorates the body of the response with content.

## Running the services

In this branch, the two main goroutines from the `master` branch have been split into two separate servers. 

In one terminal one can run the following:

1. `go build ./cmd/timeofday-server/`

2. `./timeofday-server --port=8082`

3. One can now perform the GET operation for the current time (UTC):  `curl http://localhost:8082/timeofday/v1/time`

4. The other server can be built and run using the main executable:

* `go build main.go`

* `go run main.go`

One can access the UI at http://localhost:8080/swaggerui

